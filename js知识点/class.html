<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /* class Logger {
            printName(name = 'there') {
                this.print(`Hello ${name}`);
            }

            print(text) {
                console.log(text);
            }
        }

        const logger = new Logger();
        const { printName } = logger;
        printName(); *///TypeError: Cannot read property 'print' of undefined

        //在构造方法中绑定this，这样就不会找不到print方法了。
        /* class Logger {
        constructor() {
            this.printName = this.printName.bind(this);
        }
        printName(name = 'there') {
                this.print(`Hello ${name}`);
            }

        print(text) {
                console.log(text);
            }

        } 

         const logger = new Logger();
        const { printName } = logger;
        printName(); */

       /*  class Logger {
        constructor() {
            this.printName = (name = 'there') => {
            this.print(`Hello ${name}`);
            };
        }
            print(text) {
                    console.log(text);
                }
        }

        const logger = new Logger();
        const { printName } = logger;
        printName();  */

        /* class Logger {
            printName(name = 'there') {
                this.print(`Hello ${name}`);
            }

            print(text) {
                console.log(text);
            }
        }

        function selfish (target) {
        const cache = new WeakMap();
        const handler = {
            get (target, key) {
            const value = Reflect.get(target, key);
            if (typeof value !== 'function') {
                return value;
            }
            if (!cache.has(value)) {
                cache.set(value, value.bind(target));//bind this
            }
            return cache.get(value);
            }
        };
        const proxy = new Proxy(target, handler);
        return proxy;
        }

        const logger = selfish(new Logger());
        const { printName } = logger;
        printName(); */


        class CustomHTMLElement {
            constructor(element) {
                this.element = element;
            }

            get html() {
                return this.element.innerHTML;
            }

            set html(value) {
                this.element.innerHTML = value;
            }
            }

            var descriptor = Object.getOwnPropertyDescriptor(
            CustomHTMLElement.prototype, "html"
            );//prototype?

            "get" in descriptor  // true
            "set" in descriptor  // true


            Object.assign(Point.prototype, {
            toString(){},
            toValue(){}
            });//assign？

            //Object.getPrototypeOf？  __proto__
            //new.target指向当前正在执行的函数

            //super当作一个对象使用，指向A.prototype，所以super.p()就相当于A.prototype.p()。
            //所以定义在父类实例上的方法或属性，是无法通过super调用的。
            //在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。

            //super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。
            //子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例


            //Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
            // （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。

            // （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。

            class A {
            }

            class B {
            }

            // B 的实例继承 A 的实例
            Object.setPrototypeOf(B.prototype, A.prototype);

            // B 继承 A 的静态属性
            Object.setPrototypeOf(B, A);

            const b = new B();


            Object.setPrototypeOf = function (obj, proto) {
            obj.__proto__ = proto;
            return obj;
            }


            Object.create(A.prototype);
            // 等同于
            B.prototype.__proto__ = A.prototype;

            </script>
</body>
</html>