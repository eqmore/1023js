<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
    a:link{
        color:blue;
    }
    a:visited{
        color:black;
    }
    a:hover{
        color:yellow;
    }
    a:active{
        color:red;
    }
    
    </style>
</head>
<body>
    <a href="#"><a href="#"></a></a>
    <!-- a嵌套 -->
    <a href="http://www.baidu.com">baidu</a>
    <a href="#">baidu1</a>
    <script>
    console.log('aa' in window);//true
    var aa=10;
    delete window.aa;
    console.log(window.aa);//10

    console.log(window.bb);//undefined
    console.log('bb' in window);//false  没有变量提升
    //console.log(bb);//不var访问报错
    bb=10;
    //由于变量声明自带不可删除属性，比较var num = 1 跟 num = 1，前者是变量声明，
    //带不可删除属性，因此无法被删除；后者为全局变量的一个属性，因此可以从全局变量中删除。
    delete window.bb;
    console.log(window.bb);//undefined

    /* 
        带var 
        不带var 只是全局变量的一个属性
     */


    //console.log(kuaivar);//报错
    console.log('fn out{} '+fn);//undefined
    {{{
        //console.log(kuaivar);//报错
        console.log('fn in{} before function'+fn);//fn
        let kuaivar=10;
        function fn(){}
    }}}


    console.log(kuaivar);//undefined
    console.log('fn out{} '+fn);//fn
    {{{
        console.log(kuaivar);//undefined
        console.log('fn in{} before function'+fn);//fn
        var kuaivar=10;
        function fn(){}
    }}}

    /* 
        上面两段代码对比：
        基于let创建变量，会把{}当作一个私有的块级作用域，类似函数的私有作用域，在这里重新检测语法规范，
        如果是基于新语法创建的变量，按照新语法规范解析
        function 在块级作用域只声明不定义，同var
        旧语法中function声明且定义
        let不存在变量提升，代码前的都报错
        
     */
     //___________________________
    //a=10; 
    //console.log(typeof a);//报错
    //let a=10;

    //let 虽然没有变量提升但是在当前作用域代码执行前，会语法检测，不能重复

    //___________________________
    //var a=b=3;
    //相当于执行
    //b = 3;
    //var a = b;

    //________________

    
    

    </script>
</body>
</html>