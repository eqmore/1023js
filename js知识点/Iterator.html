<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <pre>
        遍历器(Iterator)是一种机制，一种接口，为各种不同的数据结构提供
        统一的访问机制。
        本质：指针对象
        作用：<li>为各种数据结构提供一个统一的、简便的访问接口</li>
            <li>使得数据结构的成员能够按照某种次序排列</li>
            <li>Iterator接口供for...of消费</li>

            //遍历器对象（即指针对象）
            var it = makeIterator(['a', 'b']);

            it.next() // { value: "a", done: false }//当前数据成员信息
            it.next() // { value: "b", done: false }
            it.next() // { value: undefined, done: true }
            //遍历器生成函数
            function makeIterator(array) {
                var nextIndex = 0;
                return {
                  next: function() {
                    return nextIndex < array.length ?
                      {value: array[nextIndex++]} :
                      {done: true};
                  }
                };
              }
              //对象obj是可遍历的（iterable），因为具有Symbol.iterator属性
              const obj = {
                //Symbol对象的iterator属性，这是一个预定义好的、
                //类型为 Symbol 的特殊值，所以要放在方括号内
                [Symbol.iterator] : function () {
                  return {//遍历器对象
                    next: function () {
                      return {//当前成员的信息对象
                        value: 1,
                        done: true
                      };
                    }
                  };
                }
              };


              for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。
              这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。


              
        
    </pre>
    <script>
        class RangeIterator {//生成器
                constructor(start, stop) {
                  this.value = start;
                  this.stop = stop;
                }
              
                [Symbol.iterator]() { return this; }
              
                next() {
                  var value = this.value;
                  if (value < this.stop) {
                    this.value++;
                    return {done: false, value: value};
                  }
                  return {done: true, value: undefined};
                }
              }
              
              function range(start, stop) {
                return new RangeIterator(start, stop);//遍历器对象
              }
              

              for (var value of range(0, 3)) {
                console.log(value); // 0, 1, 2
              }

            //   对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。

            // 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。

            for (var key of Object.keys(someObject)) {
            console.log(key + ': ' + someObject[key]);
            }
            // 另一个方法是使用 Generator 函数将对象重新包装一下。

            function* entries(obj) {
            for (let key of Object.keys(obj)) {
                yield [key, obj[key]];
            }
            }

            for (let [key, value] of entries(obj)) {
            console.log(key, '->', value);
            }
            // a -> 1

    </script>
</body>
</html>