<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    function Prom(executor){
        let self=this;
        self.status='pending';
        self.value='undefined';
        self.reason='undefined';
        self.onfulfilled=[];
        self.onrejected=[];
        function resolve(data){
            self.status='resolved';
            self.value=data;
            self.onfulfilled.forEach(item=>item(self.value));
            console.log('resolve func done');
        } 
        function rejected(err){
            self.status='rejected';
            self.reason=err;
            console.log('rejected func done');
            console.log(self.onrejected.length)
            self.onrejected.forEach(item=>item(self.reason));
            console.log('rejected func done');
           
        }
        executor(resolve,rejected);

    }
    Prom.prototype.then=function(onfulfilled,onrejected){
        let self=this;
        let promise2;
        console.log(self.status,'then');
        if(self.status==='resolved'){
            
            return promise2=new Prom((resolve,rejected)=>{ 
                let x=onfulfilled(self.value);
                if(x instanceof Prom){
                    x.then(resolve,rejected);
                }else{
                    resolve(x);
                }
            })
            
        }
        if(self.status==='rejected'){
            console.log(self.reason);
            return promise2=new Prom((resolve,rejected)=>{
                let x=onrejected(self.reason);
                if(x instanceof Prom){
                    x.then(resolve,rejected);
                }else{
                    rejected(x);
                }
            });
        }
        if(self.status==='pending'){
            return new Prom((resolve,rejected)=>{
                self.onfulfilled.push(()=>{ 
                        let x=onfulfilled(self.value);
                        if(x instanceof Prom){
                            x.then(resolve,rejected);
                        }else{
                            resolve(x);
                        }
                    });
                self.onrejected.push(()=>{
                        let x=onrejected(self.reason);
                        if(x instanceof Prom){
                            x.then(resolve,rejected);
                        }else{
                            rejected(x);
                        }
                    });
            })
            
            
        }
    }
    //实现传递 带参数函数  promise中定义了resolve,rejected函数，执行的executor参数为这两个函数
    let p=new Prom(function(resolve,rejected){
        setTimeout(()=>{
            if(0){
                resolve('1');
            }else{
                rejected('-1');
            }
        },1000);
        
    }); 
     p.then(function(data){
        console.log(data);
        return data;
    },(err)=>{
        console.log(err)
        return err;
    }
    ).then(
        (data)=>{
            console.log(data+"1");
        },(err)=>{
            console.log(err+"1");
        }
    )

     /*  p.then(function(data){
        console.log(data);
    },function(err){
        console.log(err);
    }).then(
        (data)=>{
            console.log(data);
        },
        ()=>{
            console.log(err);
        }
    ) */

    //********怎么实现的传递一个（带两个函数参数）函数参数
    /* function a(ex){
        function re(data){
            console.log(data);
        }
        ex(re);
    }
    a(function(re){
        re(1);
    }); */



    </script>
</body>
</html>